#! /usr/bin/perl

use strict;
use warnings;

#use CracTools::SimCT::App;
use Getopt::Long qw(:config auto_version); # Get options
use Pod::Usage;   # Printing pod documentation in terminal
use File::Spec;
use Cwd 'abs_path';
use Data::Dumper;
use Tie::RefHash;

use CracTools::SimCT::Genome;
use CracTools::SimCT::Annotations;
use CracTools::SimCT::GenomeSimulator;
use CracTools::SimCT::MutationGenerator::Random;
use CracTools::SimCT::MutationGenerator::Fusion;
use CracTools::SimCT::FluxWrapper;

my ($help,$man,$verbose);
my ($genome_dir,$gtf_file,$flux_par,$sub_rate,$ins_rate,$del_rate,$nb_fusions);
my $max_splice_length = 300000;
my $output_dir = "simulation";
my $nb_process = 1;

GetOptions( "v|verbose"             => \$verbose,
            "man"                   => \$man,
            "help"                  => \$help,
            "p=i"                   => \$nb_process,
            "o|output-dir=s"        => \$output_dir,
            "g|genome-dir=s"        => \$genome_dir,
            "a|annotations=s"       => \$gtf_file,
            "f|flux-parameters=s"   => \$flux_par,
            "s|substitution-rate=f" => \$sub_rate,
            "i|insertion-rate=f"    => \$ins_rate,
            "d|deletion-rate=f"     => \$del_rate,
            "f|nb-fusions=i"        => \$nb_fusions,
          ) or pod2usage(-verbose => 1);

pod2usage(-verbose => 1)  if ($help);
pod2usage(-verbose => 2)  if ($man);

pod2usage(
  -message => "Mandatory argument '-genome-dir' is missing",
  -verbose => 1,
) unless defined $genome_dir;

pod2usage(
  -message => "Mandatory argument '-annotations' is missing",
  -verbose => 1,
) unless defined $gtf_file;

# Create an output directory if not defined
mkdir $output_dir;

# Create the reference genome
#print STDERR Dumper(\%reference_sequence_files);
print STDERR "Looking for FASTA references in $genome_dir";
opendir(GEN,$genome_dir) or die "Can't open $genome_dir: $!";
my %reference_sequence_files = map { (my $chr = $_) =~ /(?:chr)?(\S+)\.fa(?:\.gz)?$/ => File::Spec->catfile($genome_dir,$_) } grep{ /\.fa(?:\.gz)?$/ } readdir(GEN);
closedir(GEN);

#print STDERR Dumper(\%reference_sequence_files);
print STDERR "References found : \n".join("\n", map { "\t- ".$_." => ".$reference_sequence_files{$_}} keys %reference_sequence_files),"\n";

print STDERR "Calculating references length\n";
my $genome = CracTools::SimCT::Genome->new(
  reference_sequence_files => \%reference_sequence_files,
);

#print STDERR Dumper(\%reference_sequence_files);
print STDERR "Loading annotations\n";
# Create the annotations
my $annotations = CracTools::SimCT::Annotations->new();
$annotations->loadGTF($gtf_file,$genome);


# Create the GenomeSimulator
print STDERR "Building GenomeSimulator (reading annotations)\n";
my $genome_simulator = CracTools::SimCT::GenomeSimulator->new(
  genome => $genome,
);

# Generate Mutations (random)
my $mutation_generator = CracTools::SimCT::MutationGenerator::Random->new(
  genome_simulator  => $genome_simulator,
  ins_rate          => $ins_rate,
  del_rate          => $del_rate,
  sub_rate          => $sub_rate,
);

print STDERR "Generate random mutations (ins,del,sub)\n";
$mutation_generator->generateMutations();

# Generate Fusions
if(defined $nb_fusions) {
  my $fusion_generator = CracTools::SimCT::MutationGenerator::Fusion->new(
    genome_simulator  => $genome_simulator,
  );

  print STDERR "Generate random fusions\n";
  $fusion_generator->generateMutations($annotations,$nb_fusions);
}

# Create the simulated genome
print STDERR "Generate the simulated genome as FASTA and GTF\n";
my $simulated_genome_dir  = File::Spec->catfile($output_dir,"simulated_genome");
my $simulated_annotations = File::Spec->catfile($simulated_genome_dir,"annotations.gtf");
mkdir $simulated_genome_dir;
my $simulated_genome = $genome_simulator->generateGenome(
  genome_dir => $simulated_genome_dir,
  annotations => $annotations,
);

# Generate RNA-Seq reads for this genome
my $flux_wrapper    = CracTools::SimCT::FluxWrapper->new();
my $flux_output_dir = File::Spec->catfile($output_dir,"flux_simulation");
mkdir $flux_output_dir;
my $flux_outputs = $flux_wrapper->generateSimulation(
  genome_dir      => abs_path($simulated_genome_dir),
  annotation_file => abs_path($simulated_annotations),
  output_dir      => $flux_output_dir,
  flux_parameters => {
    POLYA_SHAPE   => 'NaN',
    TSS_MEAN      => 'NaN',
    READ_NUMBER   => 100000,
    READ_LENGTH   => 100,
    PAIRED_END    => 'YES',
    NB_MOLECULES  => 100000,
  },
);

# Finally we generate truth databases for this simulation
my $rnaseq_ouput_dir  = File::Spec->catfile($output_dir,"rna_seq");
mkdir $rnaseq_ouput_dir;

my %splices;
my %chimeras;
tie my %mutations, 'Tie::RefHash';


my $is_paired_end = $flux_outputs->{flux_parameters}->{PAIRED_END} eq 'YES'? 1 : 0;

# First we generates FASTQ sequences with read alignement
# and errors position encoded in the read_name
my $bed_it   = CracTools::Utils::bedFileIterator($flux_outputs->{sequencing_file}); 
my $fastq_it = CracTools::Utils::seqFileIterator($flux_outputs->{fastq_file},'fastq');

# Output is paired_end, we split files
my $fastq1_output = $is_paired_end? 
  File::Spec->catfile($rnaseq_ouput_dir,"reads_1.fastq.gz") : 
  File::Spec->catfile($rnaseq_ouput_dir,"reads.fastq.gz");
my $fastq2_output = $is_paired_end?
  File::Spec->catfile($rnaseq_ouput_dir,"reads_2.fastq.gz") : undef;
my $fastq1_output_fh = CracTools::Utils::getWritingFileHandle($fastq1_output);
my $fastq2_output_fh = $is_paired_end?
  CracTools::Utils::getWritingFileHandle($fastq2_output) : undef;

my $i = 0;
my $nb_errors = 0;
while (my $bed_line = $bed_it->()) {
  my $read = $fastq_it->();
  my $alignments = getReadAlignments(
    $bed_line,
    $simulated_genome,
    $i,
    \%splices,
    \%chimeras,
    \%mutations,
    ($i % 2 == 0) && $is_paired_end? 1 : 0,
  );
  my $errors_pos = CracTools::SimCT::FluxWrapper::getErrorsPos($read->{seq});
  $nb_errors += scalar @{$errors_pos};
  my $fh = ($i % 2 == 0) || !$is_paired_end? $fastq1_output_fh : $fastq2_output_fh;
  CracTools::Utils::writeSeq($fh,'fastq',
    getReadName($i,$alignments,$errors_pos),
    $read->{seq},
    $read->{qual}
  );
  $i++;
}
my $nb_reads = $i;

# Print gene_counts and transcript_counts files
my $transcript_counts_output = File::Spec->catfile($rnaseq_ouput_dir,"transcript-counts.tsv.gz"); 
my $transcript_counts_fh     = CracTools::Utils::getWritingFileHandle($transcript_counts_output); 
my $gene_counts_output       = File::Spec->catfile($rnaseq_ouput_dir,"gene-counts.tsv.gz"); 
my $gene_counts_fh           = CracTools::Utils::getWritingFileHandle($gene_counts_output); 
my $flux_profile_fh          = CracTools::Utils::getReadingFileHandle($flux_outputs->{profile_file});
# 1. Create a transcript_id => gene conversion hash
my %conversion_hash;
foreach my $gene ($annotations->allGenes) {
  foreach my $exon ($gene->allExons) {
    map { $conversion_hash{$_} = $gene } $exon->allTranscripts;
  }
}
# 2. Merge transrcipt counts into gene counts and print transcript counts
print $transcript_counts_fh join("\t","feature","truth"),"\n";
tie my %gene_counts, 'Tie::RefHash';
while(<$flux_profile_fh>) {
  my @fields = split("\t",$_);
  # TODO HANDLE FUSION TRANSCRIPTS!!!!
  next if !defined $conversion_hash{$fields[1]};
  $gene_counts{$conversion_hash{$fields[1]}} += $fields[9];
  print $transcript_counts_fh join("\t",$fields[1],$fields[9]),"\n";
}
# 3. Print gene counts to the corresponding output file
print $gene_counts_fh join("\t","feature","truth"),"\n";
foreach my $gene (keys %gene_counts) {
  print $gene_counts_fh join("\t",$gene->id,$gene_counts{$gene}),"\n";
}

# TODO use CracTools::Output to generate the output files

# Print Splices
# TODO sort splices by pos
if(keys %splices) {
  my $splices_output = File::Spec->catfile($rnaseq_ouput_dir,"splices.bed.gz"); 
  my $splices_fh     = CracTools::Utils::getWritingFileHandle($splices_output);
# TODO Sort splices by start position
  foreach my $splice (keys %splices) {
    my ($chr,$start,$end,$strand) = split("@",$splice);
    CracTools::SimCT::Utils::printBEDLine($splices_fh,
      { chr     => $chr,
        start   => $start,
        end     => $end, # TODO shoud we add +1 because of half-open bed?
        strand  => $strand,
        name    => join(':',@{$splices{$splice}}),
        score   => scalar @{$splices{$splice}},
      },
    );
  }
}

# Print Chimeras
# TODO sort chimeras by pos
if(keys %chimeras) {
  my $chimeras_output = File::Spec->catfile($rnaseq_ouput_dir,"chimeras.tsv.gz"); 
  my $chimeras_fh     = CracTools::Utils::getWritingFileHandle($chimeras_output);
# TODO Sort chimeras by start position
  foreach my $chimera (keys %chimeras) {
    my ($chr1,$pos1,$strand1,$chr2,$pos2,$strand2) = split("@",$chimera);
    print $chimeras_fh join("\t",
      $chr1,$pos1,$strand1,$chr2,$pos2,$strand2,
      join(':',@{$chimeras{$chimera}}),
      scalar @{$chimeras{$chimera}},
    ),"\n";
  }
}

# TODO Print Mutations
if(keys %mutations) {
  my $mutations_output = File::Spec->catfile($rnaseq_ouput_dir,"mutations.vcf.gz"); 
  my $mutations_fh     = CracTools::Utils::getWritingFileHandle($mutations_output);
  foreach my $mut (sort { $a->pos <=> $b->pos } keys %mutations) {
    # Get raw VCF record
    my $vcf_line = $mut->getVCFRecord;
    # Update information with read names and depth
    $vcf_line->{id} = join(',',@{$mutations{$mut}});
    $vcf_line->{info}->{DP} = [scalar @{$mutations{$mut}}];
    CracTools::SimCT::Utils::printVCFLine($mutations_fh,$vcf_line);
  }
}

my $info_output = File::Spec->catfile($rnaseq_ouput_dir,"info.txt"); 
my $info_fh     = CracTools::Utils::getWritingFileHandle($info_output); 
my %info = (
  nb_reads      => $nb_reads,
  nb_errors     => $nb_errors,
  nb_splices    => scalar keys %splices,
  nb_chimeras   => scalar keys %chimeras,
  nb_mutations  => scalar keys %mutations,
);
map { print $info_fh join("\t", $_, $info{$_}),"\n" } keys %info;

# Get read alignments and updates splices, mutations and chimeras
sub getReadAlignments {
  my ($bed_line, $simulated_genome, $read_id, $splices, $chimeras, $mutations, $reversed) = @_;
  my @intervals = ();
  # Create an array of intervals and retrieve mutations
  foreach my $block (@{$bed_line->{blocks}}) {
    push @intervals, [
      $bed_line->{chr},
      $block->{ref_start},
      $block->{ref_end} - 1, # because BED intervals are half-open
      $bed_line->{strand},
    ];
    # Then we get overlapping mutations
    my @overlapped_mutations = @{$simulated_genome->mutation_query->fetchByRegion(
      $bed_line->{chr},
      $block->{ref_start},
      $block->{ref_end} - 1,
    )};
    map { push @{$mutations{$_}}, $read_id } @overlapped_mutations;
  };
  # Generate the corresponding alignments
  my @alignments = $simulated_genome->liftover->getSplicedAlignments(@intervals);
  # Browse the alignments for splices and chimeras
  my $prev_alignment;
  foreach my $alignment (@alignments) {
    my $real_strand = $reversed? 
      CracTools::SimCT::Utils::reverseStrand($alignment->{strand}) : 
      $alignment->{strand},
    my @cigar;
    while($alignment->{cigar} =~ /(\d+)(\S)/g) {
      push @cigar, { op => $2, nb => $1 };
    }
    my $start = $alignment->{start};
    foreach my $cigel (@cigar) {
      if($cigel->{op} eq 'N') {
        # Add splice
        if($cigel->{nb} <= $max_splice_length) {
          my $splice_key = join("@", $alignment->{chr}, $start,
            $start + $cigel->{nb}, $real_strand);
          push @{$splices->{$splice_key}},$read_id;
        # Splice is larger than MAX_SPLICE_LENGTH, then it is a class2 chimera
        } else {
          my $chim_key = join('@', $alignment->{chr}, $start, $real_strand,
            $alignment->{chr}, $start + $cigel->{nb}, $real_strand);
          push @{$chimeras->{$chim_key}},$read_id;
        }
        $start += $cigel->{nb};
      # If this cigar op is reference based, we update
      # the start position
      } elsif($cigel->{op} =~ /^[MD]$/) {
        $start += $cigel->{nb};
      }
    }
    # If there is a previous alignment we add the corresponding chimera
    if(defined $prev_alignment) {
      my $chim_key = join("@",
        $prev_alignment->{chr},
        $prev_alignment->{reverse}? 
          $prev_alignment->{start} : $prev_alignment->{end},
        $reversed? 
          CracTools::SimCT::Utils::reverseStrand($prev_alignment->{strand}) : 
          $prev_alignment->{strand},
        $alignment->{chr},
        $alignment->{reverse}? 
          $alignment->{end} : $alignment->{start},
        $reversed? 
          CracTools::SimCT::Utils::reverseStrand($alignment->{strand}) : 
          $alignment->{strand},
      );
      push @{$chimeras->{$chim_key}},$read_id;
    }
    $prev_alignment = $alignment;
  }
  return \@alignments;
}

# Give 
sub getReadName {
  my ($read_id,$alignments,$errors_pos) = @_;
  my $read_name = join(":",
    $read_id,
    join(";",
      map { 
        join(",",
          $_->{chr},
          $_->{start},
          $_->{strand},
          $_->{cigar},
        )
      } @{$alignments},
    ),
  );
  # TODO find a better way to encode the error position with a compacting
  # strategy
  if(@{$errors_pos}) {
    $read_name = join(":",$read_name,join(",",@{$errors_pos}));
  }
  return $read_name;
}
